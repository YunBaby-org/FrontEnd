{"version":3,"sources":["webpack:///./node_modules/webstomp-client/dist/webstomp.js"],"names":["global","factory","module","exports","this","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","err","Array","isArray","toConsumableArray","arr2","from","VERSIONS","V1_0","V1_1","V1_2","supportedVersions","supportedProtocols","PROTOCOLS_VERSIONS","getSupportedVersion","protocol","debug","knownVersion","BYTES","LF","NULL","trim","str","replace","unicodeStringToTypedArray","s","escstr","encodeURIComponent","binstr","match","p1","String","fromCharCode","map","call","c","charCodeAt","Uint8Array","typedArrayToUnicodeString","ua","apply","m","p","code","toString","toUpperCase","decodeURIComponent","sizeOfUTF8","createId","ts","Date","getTime","rand","Math","floor","random","Frame","command","headers","arguments","body","_this","lines","skipContentLength","keys","forEach","name","join","data","divider","search","RegExp","headerLines","substring","split","shift","bodyIndex","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","reverse","line","idx","indexOf","return","len","parseInt","chr","charAt","datas","frames","firstFrames","slice","lastFrame","r","f","unmarshallSingle","partial","frame","Client","ws","options","_options$binary","binary","_options$heartbeat","heartbeat","outgoing","incoming","_options$debug","_options$protocols","protocols","binaryType","isBinary","hasDebug","connected","maxWebSocketFrameSize","subscriptions","partialData","_console","console","log","_parseConnect2","_parseConnect","_parseConnect3","connectCallback","errorCallback","onmessage","evt","ArrayBuffer","serverActivity","now","unmarshalledData","unmarshall","server","version","_setupHeartbeat","subscription","onreceive","messageID","ack","bind","nack","onreceipt","onclose","event","url","_cleanUp","onopen","_transmit","readyState","OPEN","disconnectCallback","close","destination","hdrs","assign","transaction","id","commit","abort","idAttr","callback","unsubscribe","clearInterval","pinger","ponger","out","marshall","_wsSend","send","_this2","_split$map","v","_split$map2","serverOutgoing","serverIncoming","ttl","max","setInterval","_ttl","delta","_len","args","_key","Function","login","passcode","host","webstomp","client","WebSocket","over","concat"],"mappings":"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","file":"js/chunk-2d2178d5.50e5ddd9.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.webstomp = factory());\n}(this, (function () { 'use strict';\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var VERSIONS = {\n      V1_0: '1.0',\n      V1_1: '1.1',\n      V1_2: '1.2',\n      // Versions of STOMP specifications supported\n      supportedVersions: function supportedVersions() {\n          return '1.2,1.1,1.0';\n      },\n      supportedProtocols: function supportedProtocols() {\n          return ['v10.stomp', 'v11.stomp', 'v12.stomp'];\n      }\n  };\n\n  var PROTOCOLS_VERSIONS = {\n      'v10.stomp': VERSIONS.V1_0,\n      'v11.stomp': VERSIONS.V1_1,\n      'v12.stomp': VERSIONS.V1_2\n  };\n\n  function getSupportedVersion(protocol, debug) {\n      var knownVersion = PROTOCOLS_VERSIONS[protocol];\n      if (!knownVersion && debug) {\n          debug('DEPRECATED: ' + protocol + ' is not a recognized STOMP version. In next major client version, this will close the connection.');\n      }\n      // 2nd temporary fallback if the protocol\n      // does not match a supported STOMP version\n      // This fallback will be removed in next major version\n      return knownVersion || VERSIONS.V1_2;\n  }\n\n  // Define constants for bytes used throughout the code.\n  var BYTES = {\n      // LINEFEED byte (octet 10)\n      LF: '\\x0A',\n      // NULL byte (octet 0)\n      NULL: '\\x00'\n  };\n\n  // utility function to trim any whitespace before and after a string\n  var trim = function trim(str) {\n      return str.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function unicodeStringToTypedArray(s) {\n      var escstr = encodeURIComponent(s);\n      var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n          return String.fromCharCode('0x' + p1);\n      });\n      var arr = Array.prototype.map.call(binstr, function (c) {\n          return c.charCodeAt(0);\n      });\n      return new Uint8Array(arr);\n  }\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function typedArrayToUnicodeString(ua) {\n      var binstr = String.fromCharCode.apply(String, toConsumableArray(ua));\n      var escstr = binstr.replace(/(.)/g, function (m, p) {\n          var code = p.charCodeAt(0).toString(16).toUpperCase();\n          if (code.length < 2) {\n              code = '0' + code;\n          }\n          return '%' + code;\n      });\n      return decodeURIComponent(escstr);\n  }\n\n  // Compute the size of a UTF-8 string by counting its number of bytes\n  // (and not the number of characters composing the string)\n  function sizeOfUTF8(s) {\n      if (!s) return 0;\n      return encodeURIComponent(s).match(/%..|./g).length;\n  }\n\n  function createId() {\n      var ts = new Date().getTime();\n      var rand = Math.floor(Math.random() * 1000);\n      return ts + '-' + rand;\n  }\n\n  // [STOMP Frame](http://stomp.github.com/stomp-specification-1.1.html#STOMP_Frames) Class\n\n  var Frame = function () {\n\n      // Frame constructor\n      function Frame(command) {\n          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n          classCallCheck(this, Frame);\n\n          this.command = command;\n          this.headers = headers;\n          this.body = body;\n      }\n\n      // Provides a textual representation of the frame\n      // suitable to be sent to the server\n\n\n      createClass(Frame, [{\n          key: 'toString',\n          value: function toString() {\n              var _this = this;\n\n              var lines = [this.command],\n                  skipContentLength = this.headers['content-length'] === false;\n              if (skipContentLength) delete this.headers['content-length'];\n\n              Object.keys(this.headers).forEach(function (name) {\n                  var value = _this.headers[name];\n                  lines.push(name + ':' + value);\n              });\n\n              if (this.body && !skipContentLength) {\n                  lines.push('content-length:' + sizeOfUTF8(this.body));\n              }\n\n              lines.push(BYTES.LF + this.body);\n\n              return lines.join(BYTES.LF);\n          }\n\n          // Unmarshall a single STOMP frame from a `data` string\n\n      }], [{\n          key: 'unmarshallSingle',\n          value: function unmarshallSingle(data) {\n              // search for 2 consecutives LF byte to split the command\n              // and headers from the body\n              var divider = data.search(new RegExp(BYTES.LF + BYTES.LF)),\n                  headerLines = data.substring(0, divider).split(BYTES.LF),\n                  command = headerLines.shift(),\n                  headers = {},\n                  body = '',\n\n              // skip the 2 LF bytes that divides the headers from the body\n              bodyIndex = divider + 2;\n\n              // Parse headers in reverse order so that for repeated headers, the 1st\n              // value is used\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                  for (var _iterator = headerLines.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var line = _step.value;\n\n                      var idx = line.indexOf(':');\n                      headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n                  }\n                  // Parse body\n                  // check for content-length or topping at the first NULL byte found.\n              } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n              } finally {\n                  try {\n                      if (!_iteratorNormalCompletion && _iterator.return) {\n                          _iterator.return();\n                      }\n                  } finally {\n                      if (_didIteratorError) {\n                          throw _iteratorError;\n                      }\n                  }\n              }\n\n              if (headers['content-length']) {\n                  var len = parseInt(headers['content-length'], 10);\n                  body = ('' + data).substring(bodyIndex, bodyIndex + len);\n              } else {\n                  var chr = null;\n                  for (var i = bodyIndex; i < data.length; i++) {\n                      chr = data.charAt(i);\n                      if (chr === BYTES.NULL) break;\n                      body += chr;\n                  }\n              }\n\n              return new Frame(command, headers, body);\n          }\n\n          // Split the data before unmarshalling every single STOMP frame.\n          // Web socket servers can send multiple frames in a single websocket message.\n          // If the message size exceeds the websocket message size, then a single\n          // frame can be fragmented across multiple messages.\n          //\n          // `datas` is a string.\n          //\n          // returns an *array* of Frame objects\n\n      }, {\n          key: 'unmarshall',\n          value: function unmarshall(datas) {\n              // split and unmarshall *multiple STOMP frames* contained in a *single WebSocket frame*.\n              // The data is split when a NULL byte (followed by zero or many LF bytes) is found\n              var frames = datas.split(new RegExp(BYTES.NULL + BYTES.LF + '*')),\n                  firstFrames = frames.slice(0, -1),\n                  lastFrame = frames.slice(-1)[0],\n                  r = {\n                  frames: firstFrames.map(function (f) {\n                      return Frame.unmarshallSingle(f);\n                  }),\n                  partial: ''\n              };\n\n              // If this contains a final full message or just a acknowledgement of a PING\n              // without any other content, process this frame, otherwise return the\n              // contents of the buffer to the caller.\n              if (lastFrame === BYTES.LF || lastFrame.search(RegExp(BYTES.NULL + BYTES.LF + '*$')) !== -1) {\n                  r.frames.push(Frame.unmarshallSingle(lastFrame));\n              } else {\n                  r.partial = lastFrame;\n              }\n\n              return r;\n          }\n\n          // Marshall a Stomp frame\n\n      }, {\n          key: 'marshall',\n          value: function marshall(command, headers, body) {\n              var frame = new Frame(command, headers, body);\n              return frame.toString() + BYTES.NULL;\n          }\n      }]);\n      return Frame;\n  }();\n\n  // STOMP Client Class\n  //\n  // All STOMP protocol is exposed as methods of this class (`connect()`,\n  // `send()`, etc.)\n\n  var Client = function () {\n      function Client(ws) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          classCallCheck(this, Client);\n\n          // cannot have default options object + destructuring in the same time in method signature\n          var _options$binary = options.binary,\n              binary = _options$binary === undefined ? false : _options$binary,\n              _options$heartbeat = options.heartbeat,\n              heartbeat = _options$heartbeat === undefined ? { outgoing: 10000, incoming: 10000 } : _options$heartbeat,\n              _options$debug = options.debug,\n              debug = _options$debug === undefined ? true : _options$debug,\n              _options$protocols = options.protocols,\n              protocols = _options$protocols === undefined ? [] : _options$protocols;\n\n\n          this.ws = ws;\n          this.ws.binaryType = 'arraybuffer';\n          this.isBinary = !!binary;\n          this.hasDebug = !!debug;\n          this.connected = false;\n          // Heartbeat properties of the client\n          // outgoing: send heartbeat every 10s by default (value is in ms)\n          // incoming: expect to receive server heartbeat at least every 10s by default\n          // falsy value means no heartbeat hence 0,0\n          this.heartbeat = heartbeat || { outgoing: 0, incoming: 0 };\n          // maximum *WebSocket* frame size sent by the client. If the STOMP frame\n          // is bigger than this value, the STOMP frame will be sent using multiple\n          // WebSocket frames (default is 16KiB)\n          this.maxWebSocketFrameSize = 16 * 1024;\n          // subscription callbacks indexed by subscriber's ID\n          this.subscriptions = {};\n          this.partialData = '';\n          this.protocols = protocols;\n      }\n\n      // //// Debugging\n      //\n      // By default, debug messages are logged in the window's console if it is defined.\n      // This method is called for every actual transmission of the STOMP frames over the\n      // WebSocket.\n      //\n      // It is possible to set a `debug(message, data)` method\n      // on a client instance to handle differently the debug messages:\n      //\n      //     client.debug = function(str) {\n      //         // append the debug log to a #debug div\n      //         $(\"#debug\").append(str + \"\\n\");\n      //     };\n\n\n      createClass(Client, [{\n          key: 'debug',\n          value: function debug() {\n              var _console;\n\n              if (this.hasDebug) (_console = console).log.apply(_console, arguments);\n          }\n\n          // [CONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECT_or_STOMP_Frame)\n          //\n          // The `connect` method accepts different number of arguments and types:\n          //\n          // * `connect(headers, connectCallback)`\n          // * `connect(headers, connectCallback, errorCallback)`\n          // * `connect(login, passcode, connectCallback)`\n          // * `connect(login, passcode, connectCallback, errorCallback)`\n          // * `connect(login, passcode, connectCallback, errorCallback, host)`\n          //\n          // The errorCallback is optional and the 2 first forms allow to pass other\n          // headers in addition to `client`, `passcode` and `host`.\n\n      }, {\n          key: 'connect',\n          value: function connect() {\n              var _this = this;\n\n              var _parseConnect2 = this._parseConnect.apply(this, arguments),\n                  _parseConnect3 = slicedToArray(_parseConnect2, 3),\n                  headers = _parseConnect3[0],\n                  connectCallback = _parseConnect3[1],\n                  errorCallback = _parseConnect3[2];\n\n              this.connectCallback = connectCallback;\n              this.debug('Opening Web Socket...');\n              this.ws.onmessage = function (evt) {\n                  var data = evt.data;\n                  if (evt.data instanceof ArrayBuffer) {\n                      data = typedArrayToUnicodeString(new Uint8Array(evt.data));\n                  }\n                  _this.serverActivity = Date.now();\n                  // heartbeat\n                  if (data === BYTES.LF) {\n                      _this.debug('<<< PONG');\n                      return;\n                  }\n                  _this.debug('<<< ' + data);\n                  // Handle STOMP frames received from the server\n                  // The unmarshall function returns the frames parsed and any remaining\n                  // data from partial frames.\n                  var unmarshalledData = Frame.unmarshall(_this.partialData + data);\n                  _this.partialData = unmarshalledData.partial;\n                  unmarshalledData.frames.forEach(function (frame) {\n                      switch (frame.command) {\n                          // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECTED_Frame)\n                          case 'CONNECTED':\n                              _this.debug('connected to server ' + frame.headers.server);\n                              _this.connected = true;\n                              _this.version = frame.headers.version;\n                              _this._setupHeartbeat(frame.headers);\n                              if (connectCallback) connectCallback(frame);\n                              break;\n                          // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.1.html#MESSAGE)\n                          case 'MESSAGE':\n                              // the `onreceive` callback is registered when the client calls\n                              // `subscribe()`.\n                              // If there is registered subscription for the received message,\n                              // we used the default `onreceive` method that the client can set.\n                              // This is useful for subscriptions that are automatically created\n                              // on the browser side (e.g. [RabbitMQ's temporary\n                              // queues](http://www.rabbitmq.com/stomp.html)).\n                              var subscription = frame.headers.subscription;\n                              var onreceive = _this.subscriptions[subscription] || _this.onreceive;\n                              if (onreceive) {\n                                  // 1.2 define ack header if ack is set to client\n                                  // and this header must be used for ack/nack\n                                  var messageID = _this.version === VERSIONS.V1_2 && frame.headers.ack || frame.headers['message-id'];\n                                  // add `ack()` and `nack()` methods directly to the returned frame\n                                  // so that a simple call to `message.ack()` can acknowledge the message.\n                                  frame.ack = _this.ack.bind(_this, messageID, subscription);\n                                  frame.nack = _this.nack.bind(_this, messageID, subscription);\n                                  onreceive(frame);\n                              } else {\n                                  _this.debug('Unhandled received MESSAGE: ' + frame);\n                              }\n                              break;\n                          // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.1.html#RECEIPT)\n                          //\n                          // The client instance can set its `onreceipt` field to a function taking\n                          // a frame argument that will be called when a receipt is received from\n                          // the server:\n                          //\n                          //     client.onreceipt = function(frame) {\n                          //       receiptID = frame.headers['receipt-id'];\n                          //       ...\n                          //     }\n                          case 'RECEIPT':\n                              if (_this.onreceipt) _this.onreceipt(frame);\n                              break;\n                          // [ERROR Frame](http://stomp.github.com/stomp-specification-1.1.html#ERROR)\n                          case 'ERROR':\n                              if (errorCallback) errorCallback(frame);\n                              break;\n                          default:\n                              _this.debug('Unhandled frame: ' + frame);\n                      }\n                  });\n              };\n              this.ws.onclose = function (event) {\n                  _this.debug('Whoops! Lost connection to ' + _this.ws.url + ':', { event: event });\n                  _this._cleanUp();\n                  if (errorCallback) errorCallback(event);\n              };\n              this.ws.onopen = function () {\n                  _this.debug('Web Socket Opened...');\n                  // 1st protocol fallback on user 1st protocols options\n                  // to prevent edge case where server does not comply and respond with a choosen protocol\n                  // or when ws client does not handle protocol property very well\n                  headers['accept-version'] = getSupportedVersion(_this.ws.protocol || _this.protocols[0], _this.debug.bind(_this));\n                  // Check if we already have heart-beat in headers before adding them\n                  if (!headers['heart-beat']) {\n                      headers['heart-beat'] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n                  }\n                  _this._transmit('CONNECT', headers);\n              };\n              if (this.ws.readyState === this.ws.OPEN) {\n                  this.ws.onopen();\n              }\n          }\n\n          // [DISCONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#DISCONNECT)\n\n      }, {\n          key: 'disconnect',\n          value: function disconnect(disconnectCallback) {\n              var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              this._transmit('DISCONNECT', headers);\n              // Discard the onclose callback to avoid calling the errorCallback when\n              // the client is properly disconnected.\n              this.ws.onclose = null;\n              this.ws.close();\n              this._cleanUp();\n              // TODO: what's the point of this callback disconnect is not async\n              if (disconnectCallback) disconnectCallback();\n          }\n\n          // [SEND Frame](http://stomp.github.com/stomp-specification-1.1.html#SEND)\n          //\n          // * `destination` is MANDATORY.\n\n      }, {\n          key: 'send',\n          value: function send(destination) {\n              var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              hdrs.destination = destination;\n              this._transmit('SEND', hdrs, body);\n          }\n\n          // [BEGIN Frame](http://stomp.github.com/stomp-specification-1.1.html#BEGIN)\n          //\n          // If no transaction ID is passed, one will be created automatically\n\n      }, {\n          key: 'begin',\n          value: function begin() {\n              var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tx-' + createId();\n\n              this._transmit('BEGIN', { transaction: transaction });\n              return {\n                  id: transaction,\n                  commit: this.commit.bind(this, transaction),\n                  abort: this.abort.bind(this, transaction)\n              };\n          }\n\n          // [COMMIT Frame](http://stomp.github.com/stomp-specification-1.1.html#COMMIT)\n          //\n          // * `transaction` is MANDATORY.\n          //\n          // It is preferable to commit a transaction by calling `commit()` directly on\n          // the object returned by `client.begin()`:\n          //\n          //     var tx = client.begin(txid);\n          //     ...\n          //     tx.commit();\n\n      }, {\n          key: 'commit',\n          value: function commit(transaction) {\n              this._transmit('COMMIT', { transaction: transaction });\n          }\n\n          // [ABORT Frame](http://stomp.github.com/stomp-specification-1.1.html#ABORT)\n          //\n          // * `transaction` is MANDATORY.\n          //\n          // It is preferable to abort a transaction by calling `abort()` directly on\n          // the object returned by `client.begin()`:\n          //\n          //     var tx = client.begin(txid);\n          //     ...\n          //     tx.abort();\n\n      }, {\n          key: 'abort',\n          value: function abort(transaction) {\n              this._transmit('ABORT', { transaction: transaction });\n          }\n\n          // [ACK Frame](http://stomp.github.com/stomp-specification-1.1.html#ACK)\n          //\n          // * `messageID` & `subscription` are MANDATORY.\n          //\n          // It is preferable to acknowledge a message by calling `ack()` directly\n          // on the message handled by a subscription callback:\n          //\n          //     client.subscribe(destination,\n          //       function(message) {\n          //         // process the message\n          //         // acknowledge it\n          //         message.ack();\n          //       },\n          //       {'ack': 'client'}\n          //     );\n\n      }, {\n          key: 'ack',\n          value: function ack(messageID, subscription) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // 1.2 change id header name from message-id to id\n              var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n              hdrs[idAttr] = messageID;\n              hdrs.subscription = subscription;\n              this._transmit('ACK', hdrs);\n          }\n\n          // [NACK Frame](http://stomp.github.com/stomp-specification-1.1.html#NACK)\n          //\n          // * `messageID` & `subscription` are MANDATORY.\n          //\n          // It is preferable to nack a message by calling `nack()` directly on the\n          // message handled by a subscription callback:\n          //\n          //     client.subscribe(destination,\n          //       function(message) {\n          //         // process the message\n          //         // an error occurs, nack it\n          //         message.nack();\n          //       },\n          //       {'ack': 'client'}\n          //     );\n\n      }, {\n          key: 'nack',\n          value: function nack(messageID, subscription) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // 1.2 change id header name from message-id to id\n              var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n              hdrs[idAttr] = messageID;\n              hdrs.subscription = subscription;\n              this._transmit('NACK', hdrs);\n          }\n\n          // [SUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#SUBSCRIBE)\n\n      }, {\n          key: 'subscribe',\n          value: function subscribe(destination, callback) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // for convenience if the `id` header is not set, we create a new one for this client\n              // that will be returned to be able to unsubscribe this subscription\n              if (!hdrs.id) hdrs.id = 'sub-' + createId();\n              hdrs.destination = destination;\n              this.subscriptions[hdrs.id] = callback;\n              this._transmit('SUBSCRIBE', hdrs);\n              return {\n                  id: hdrs.id,\n                  unsubscribe: this.unsubscribe.bind(this, hdrs.id)\n              };\n          }\n\n          // [UNSUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#UNSUBSCRIBE)\n          //\n          // * `id` is MANDATORY.\n          //\n          // It is preferable to unsubscribe from a subscription by calling\n          // `unsubscribe()` directly on the object returned by `client.subscribe()`:\n          //\n          //     var subscription = client.subscribe(destination, onmessage);\n          //     ...\n          //     subscription.unsubscribe(headers);\n\n      }, {\n          key: 'unsubscribe',\n          value: function unsubscribe(id) {\n              var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              var hdrs = Object.assign({}, headers);\n              delete this.subscriptions[id];\n              hdrs.id = id;\n              this._transmit('UNSUBSCRIBE', hdrs);\n          }\n\n          // Clean up client resources when it is disconnected or the server did not\n          // send heart beats in a timely fashion\n\n      }, {\n          key: '_cleanUp',\n          value: function _cleanUp() {\n              this.connected = false;\n              clearInterval(this.pinger);\n              clearInterval(this.ponger);\n          }\n\n          // Base method to transmit any stomp frame\n\n      }, {\n          key: '_transmit',\n          value: function _transmit(command, headers, body) {\n              var out = Frame.marshall(command, headers, body);\n              this.debug('>>> ' + out, { frame: { command: command, headers: headers, body: body } });\n              this._wsSend(out);\n          }\n      }, {\n          key: '_wsSend',\n          value: function _wsSend(data) {\n              if (this.isBinary) data = unicodeStringToTypedArray(data);\n              this.debug('>>> length ' + data.length);\n              // if necessary, split the *STOMP* frame to send it on many smaller\n              // *WebSocket* frames\n              while (true) {\n                  if (data.length > this.maxWebSocketFrameSize) {\n                      this.ws.send(data.slice(0, this.maxWebSocketFrameSize));\n                      data = data.slice(this.maxWebSocketFrameSize);\n                      this.debug('remaining = ' + data.length);\n                  } else {\n                      return this.ws.send(data);\n                  }\n              }\n          }\n\n          // Heart-beat negotiation\n\n      }, {\n          key: '_setupHeartbeat',\n          value: function _setupHeartbeat(headers) {\n              var _this2 = this;\n\n              if (this.version !== VERSIONS.V1_1 && this.version !== VERSIONS.V1_2) return;\n\n              // heart-beat header received from the server looks like:\n              //\n              //     heart-beat: sx, sy\n\n              var _split$map = (headers['heart-beat'] || '0,0').split(',').map(function (v) {\n                  return parseInt(v, 10);\n              }),\n                  _split$map2 = slicedToArray(_split$map, 2),\n                  serverOutgoing = _split$map2[0],\n                  serverIncoming = _split$map2[1];\n\n              if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n                  var ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n                  this.debug('send PING every ' + ttl + 'ms');\n                  this.pinger = setInterval(function () {\n                      _this2._wsSend(BYTES.LF);\n                      _this2.debug('>>> PING');\n                  }, ttl);\n              }\n\n              if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n                  var _ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n                  this.debug('check PONG every ' + _ttl + 'ms');\n                  this.ponger = setInterval(function () {\n                      var delta = Date.now() - _this2.serverActivity;\n                      // We wait twice the TTL to be flexible on window's setInterval calls\n                      if (delta > _ttl * 2) {\n                          _this2.debug('did not receive server activity for the last ' + delta + 'ms');\n                          _this2.ws.close();\n                      }\n                  }, _ttl);\n              }\n          }\n\n          // parse the arguments number and type to find the headers, connectCallback and\n          // (eventually undefined) errorCallback\n\n      }, {\n          key: '_parseConnect',\n          value: function _parseConnect() {\n              var headers = {},\n                  connectCallback = void 0,\n                  errorCallback = void 0;\n\n              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n              }\n\n              switch (args.length) {\n                  case 2:\n                      headers = args[0];\n                      connectCallback = args[1];\n\n                      break;\n                  case 3:\n                      if (args[1] instanceof Function) {\n                          headers = args[0];\n                          connectCallback = args[1];\n                          errorCallback = args[2];\n                      } else {\n                          headers.login = args[0];\n                          headers.passcode = args[1];\n                          connectCallback = args[2];\n                      }\n                      break;\n                  case 4:\n                      headers.login = args[0];\n                      headers.passcode = args[1];\n                      connectCallback = args[2];\n                      errorCallback = args[3];\n\n                      break;\n                  default:\n                      headers.login = args[0];\n                      headers.passcode = args[1];\n                      connectCallback = args[2];\n                      errorCallback = args[3];\n                      headers.host = args[4];\n\n              }\n\n              return [headers, connectCallback, errorCallback];\n          }\n      }]);\n      return Client;\n  }();\n\n  // The `webstomp` Object\n  var webstomp = {\n      Frame: Frame,\n      VERSIONS: VERSIONS,\n      // This method creates a WebSocket client that is connected to\n      // the STOMP server located at the url.\n      client: function client(url) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          var ws = new WebSocket(url, options.protocols || VERSIONS.supportedProtocols());\n          return new Client(ws, options);\n      },\n\n      // This method is an alternative to `webstomp.client()` to let the user\n      // specify the WebSocket to use (either a standard HTML5 WebSocket or\n      // a similar object).\n      over: function over() {\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n          }\n\n          return new (Function.prototype.bind.apply(Client, [null].concat(args)))();\n      }\n  };\n\n  return webstomp;\n\n})));\n"],"sourceRoot":""}